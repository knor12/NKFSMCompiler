/*
*this file is auto generated by NKCompiler, do not edit manualy 
*@file TraficLightFSM.c
*@date 2022-12-12
*@author n.kessa
*@brief state machine TraficLightFSM FSM code
*/

#include "TraficLightFSM.h" 
#include "TraficLightGlue.h" 

#include <stdlib.h> 


#define MAX_NUM_STATES (7)


/*initialization function*/
void TraficLightFSM_Init(struct TraficLightFSM * fsm)
{
    fsm->state=TraficLight_init;
    fsm->transitions=0u; 
}

/*this function processes the event on based on current state and conditions specified.*/
int TraficLightFSM_on(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if (fsm->state == TraficLight_init)
    {
        ret=oInit(o);
        
        ret|=iwarmUp(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_warmup;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                ret|= TraficLightFSM_any(fsm,o);/* on entry rased event*/
        return ret;
    }
    
    return 0;
}


/*this function processes the event any based on current state and conditions specified.*/
int TraficLightFSM_any(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if ((fsm->state == TraficLight_warmup)/*move to next state anyway*/)
    {
        ret=owarmUp(o);
        
        ret|=iLightOff(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_red_Lightoff;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}


/*this function processes the event off based on current state and conditions specified.*/
int TraficLightFSM_off(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if (fsm->state == TraficLight_red_Lightoff)
    {
        ret=oLightOff(o);
        
        ret|=iInit(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_init;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    

    
    if (fsm->state == TraficLight_red_redOn_redOnL1)
    {
        ret=oRedOnL1(o);
        
        ret|=iInit(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_init;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    

    
    if (fsm->state == TraficLight_red_preinit)
    {
        
        
        ret|=iInit(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_init;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    

    
    if (fsm->state == TraficLight_red_redOn_redOnL2)
    {
        ret=oRedOnL2(o);
        
        ret|=iInit(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_init;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}


/*this function processes the event timeOut1 based on current state and conditions specified.*/
int TraficLightFSM_timeOut1(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if (fsm->state == TraficLight_red_Lightoff)
    {
        ret=oLightOff(o);
        
        ret|=iRedOnL1(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_red_redOn_redOnL1;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}


/*this function processes the event timeOut10 based on current state and conditions specified.*/
int TraficLightFSM_timeOut10(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if (fsm->state == TraficLight_red_redOn_redOnL1)
    {
        ret=oRedOnL1(o);
        
        ret|=iLightOff(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_red_Lightoff;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    

    
    if (fsm->state == TraficLight_red_redOn_redOnL2)
    {
        ret=oRedOnL2(o);
        
        ret|=iLightOff(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_red_Lightoff;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}


/*this function processes the event timeOut2 based on current state and conditions specified.*/
int TraficLightFSM_timeOut2(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if (fsm->state == TraficLight_red_redOn_redOnL1)
    {
        ret=oRedOnL1(o);
        
        ret|=iRedOnL2(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_red_redOn_redOnL2;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}


/*this function processes the event timeOut3 based on current state and conditions specified.*/
int TraficLightFSM_timeOut3(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if (fsm->state == TraficLight_red_redOn_redOnL2)
    {
        ret=oRedOnL2(o);
        
        ret|=iRedOnL1(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_red_redOn_redOnL1;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}


/*this function processes the event timeOut40 based on current state and conditions specified.*/
int TraficLightFSM_timeOut40(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if ((fsm->state == TraficLight_red_redOn_redOnL2)/*some news*/)
    {
        ret=oRedOnL2(o);
        
        
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_red_preinit;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}


/*this function processes the event timeOut100 based on current state and conditions specified.*/
int TraficLightFSM_timeOut100(struct TraficLightFSM * fsm, void * o)
{

    int ret = 0; 

    
    if (fsm->state == TraficLight_red_preinit)
    {
        
        
        ret|=iInit(o);
        if (ret >= 0)
        {
            fsm->transitions++;
            fsm->state = TraficLight_init;
        }else 
        {
            fsm->transitions++;
            fsm->state = TraficLight_errorState;
        }
                        return ret;
    }
    
    return 0;
}
