__author__      = "Noreddine Kessa"
__copyright__   = "!"
__license__ = "MIT License"

from NKModelRoot import *
from NKModelTransition import *
from NKFSMVersion import *
from datetime import date
import os 

class NKGeneratorFSMSource:

    def __init__(self, transitions, directory):
        self.transitions =transitions
        self.directory=directory
        self.filename=f'{transitions.Name}FSM'
        self.GlueName=f'{transitions.Name}Glue'
        self.FSMStates_t=f'FSM{transitions.Name}_State_t'
        self.structName = f'{transitions.Name}FSM'
   
    def __str__(self):
        events = self.transitions.getEvents()
        states = self.transitions.getStates()
        transitions = self.transitions.transitions
        
        
        st = f"\
/*\n\
*this file is auto generated by NKCompiler {NKFSMVersion().getVersion()}, do not edit manualy \n\
*@file {self.filename}.c\n\
*@date {date.today()}\n\
*@author n.kessa\n\
*@brief state machine {self.filename} FSM code\n\
*/\n\
\n\
#include \"{self.filename}.h\" \n\
#include \"{self.GlueName}.h\" \n\
\n\
#include <stdlib.h> \n\
\n\
\n\
#define MAX_NUM_STATES ({len(states)})\
\n\
\n\
"

#add the initialization function
        st+=f"\n\
/*initialization function*/\n\
void {self.structName}_Init(struct {self.structName} * fsm)\n\
{{\n\
    fsm->state={self.transitions.initialState};\n\
    fsm->transitions=0u; \n\
}}"

#add routing for each event
        for event in events:
            #event handler name
            st+=f'\n\n\
/*this function processes the event {event} based on current state and conditions specified.*/\n\
int {self.structName}_{event}(struct {self.structName} * fsm, void * o)\n\
{{\n\
\n\
    int ret = 0; \n'
            for transition in transitions:
                handler="\n"
                OnEnter ="\n"
                OnExit="\n"
                Condition=""
                raiseEventEntry=""
                raiseEventExit=""
                #only add onExit, if the state actualy changes   
                if ((transition.OnExit!="") and ((transition.OriginalState != transition.NewState)or True) ):
                    OnExit = f'ret={transition.OnExit}(fsm, o);\n'
                #only add OnEnter, if the state actualy changes    
                if ((transition.OnEnter!="") and ((transition.OriginalState != transition.NewState) or True) ):
                    OnEnter = f'ret|={transition.OnEnter}(fsm, o);\n'
                if (transition.TransitionHandler!=""):
                    handler = f'ret|={transition.TransitionHandler}(fsm, o);\n'
                #assemble the transition condition
                Condition= f'fsm->state == {transition.OriginalState}'
                if (transition.Condition!=""):
                    Condition = f'({Condition}){transition.Condition}'
                #see if we have to execute a rotine for raised events
                if (transition.OnEntryRaiseEvent!=""):
                    raiseEventEntry= f'ret|= {self.structName}_{transition.OnEntryRaiseEvent}(fsm,o);/* on entry rased event*/\n'
                #see if we have to execute a rotine for raised events
                if (transition.OnExitRaiseEvent!=""):
                    raiseEventExit= f'ret|= {self.structName}_{transition.OnExitRaiseEvent}(fsm,o);/*on exit rased event*/\n'                    
                    
                    
                if event == transition.Event:
                    st+=f"\n\
    {transition.Comment}\n\
    if ({Condition})\n\
    {{\n\
        {OnExit}\
        {handler}\
        {OnEnter}\
        if (ret >= 0)\n\
        {{\n\
            fsm->transitions++;\n\
            fsm->state = {transition.NewState};\n\
        }}else \n\
        {{\n\
            fsm->transitions++;\n\
            fsm->state = {self.transitions.errorSate};\n\
        }}\n\
        {raiseEventExit}\
        {raiseEventEntry}\
        return ret;\n\
    }}\n\
    \n"

            st+=f'\
    return 0;\n\
}}\n'


        return st
        
        
    def writeToFile(self):
        filename = self.filename
        filePath=os.path.join(self.directory,filename+".c" )
        #it is OK to overide FSM source, the user should edit it manualy any ways
        #while (os.path.exists(filePath)):
        #   filename = filename + "New" 
        #   filePath=os.path.join(self.directory,filename+".c" ) 
        
        print(f'writing to {filePath}')    
        out = open(filePath, "w")
 
        #write string to file
        out.write(f'{self}')
 
        #close file
        out.close()   